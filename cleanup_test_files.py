#!/usr/bin/env python3
"""
Test Files Cleanup Script (Enhanced Version)

This script cleans up test files, directories, __pycache__ folders, 
and all test-related temporary files generated by test_and_validation.py.
"""

import os
import shutil
import argparse
from pathlib import Path
import glob

def cleanup_test_files(project_dir: str, confirm: bool = True, clean_cache: bool = True):
    """Clean up test files, directories, __pycache__ folders, and temporary files"""
    project_path = Path(project_dir)
    
    # Define paths to clean
    paths_to_clean = [
        project_path / "result" / "test_results",
        project_path / "audio" / "test_audio", 
        project_path / "configs" / "test_configs"
    ]
    
    # Find files and directories to clean
    files_to_clean = []
    dirs_to_clean = []
    
    for path in paths_to_clean:
        if path.exists():
            if path.is_dir():
                dirs_to_clean.append(path)
                # Count files in directory
                file_count = len(list(path.rglob('*'))) if path.exists() else 0
                files_to_clean.extend(list(path.rglob('*')))
            else:
                files_to_clean.append(path)
    
    # Also clean any test CSV files in result directory
    result_dir = project_path / "result"
    if result_dir.exists():
        test_csvs = list(result_dir.glob("test_*.csv"))
        files_to_clean.extend(test_csvs)
    
    # Clean temporary CSV files in csv directory
    csv_dir = project_path / "csv"
    if csv_dir.exists():
        temp_csvs = list(csv_dir.glob("temp_test_*.csv"))
        files_to_clean.extend(temp_csvs)
    
    # Clean TestCodec related files in result directory
    if result_dir.exists():
        testcodec_detailed = list(result_dir.glob("detailed_results_TestCodec_*.csv"))
        testcodec_summary = list(result_dir.glob("summary_results_TestCodec_*.csv"))
        files_to_clean.extend(testcodec_detailed)
        files_to_clean.extend(testcodec_summary)
    
    # Clean TestCodec config files
    config_dir = project_path / "configs"
    if config_dir.exists():
        testcodec_configs = list(config_dir.glob("TestCodec_*.json"))
        test_configs = list(config_dir.glob("test_config_*.json"))
        files_to_clean.extend(testcodec_configs)
        files_to_clean.extend(test_configs)
    
    # Clean TestCodec audio files
    audio_dir = project_path / "audio"
    if audio_dir.exists():
        # LibriSpeech test audio
        librispeech_testcodec = audio_dir / "LibriSpeech" / "TestCodec"
        if librispeech_testcodec.exists():
            dirs_to_clean.append(librispeech_testcodec)
        
        # CommonVoice test audio
        commonvoice_testcodec = audio_dir / "CommonVoice" / "TestCodec"
        if commonvoice_testcodec.exists():
            dirs_to_clean.append(commonvoice_testcodec)
    
    # Find __pycache__ directories if requested
    pycache_dirs = []
    if clean_cache:
        pycache_dirs = list(project_path.rglob('__pycache__'))
    
    # Count unique files (avoid duplicates)
    unique_files = set()
    for f in files_to_clean:
        if f.is_file():
            unique_files.add(f)
    
    print("="*60)
    print("TEST FILES AND CACHE CLEANUP (ENHANCED)")
    print("="*60)
    print(f"Project directory: {project_path}")
    print(f"Directories to remove: {len(dirs_to_clean)}")
    print(f"Files to remove: {len(unique_files)}")
    if clean_cache:
        print(f"__pycache__ directories to remove: {len(pycache_dirs)}")
    print("="*60)
    
    if dirs_to_clean:
        print(f"\nTEST DIRECTORIES TO REMOVE:")
        for dir_path in dirs_to_clean:
            if dir_path.exists():
                file_count = len([f for f in dir_path.rglob('*') if f.is_file()])
                print(f"  • {dir_path.relative_to(project_path)} ({file_count} files)")
    
    if clean_cache and pycache_dirs:
        print(f"\n__PYCACHE__ DIRECTORIES TO REMOVE:")
        for dir_path in pycache_dirs[:10]:
            print(f"  • {dir_path.relative_to(project_path)}")
        if len(pycache_dirs) > 10:
            print(f"  ... and {len(pycache_dirs) - 10} more")
    
    # Categorize files by type
    csv_files = [f for f in unique_files if f.suffix == '.csv']
    json_files = [f for f in unique_files if f.suffix == '.json']
    audio_files = [f for f in unique_files if f.suffix in ['.wav', '.flac', '.mp3']]
    other_files = [f for f in unique_files if f not in csv_files + json_files + audio_files]
    
    if csv_files:
        print(f"\nCSV FILES TO REMOVE ({len(csv_files)}):")
        for csv_file in csv_files[:5]:
            print(f"  • {csv_file.relative_to(project_path)}")
        if len(csv_files) > 5:
            print(f"  ... and {len(csv_files) - 5} more")
    
    if json_files:
        print(f"\nJSON CONFIG FILES TO REMOVE ({len(json_files)}):")
        for json_file in json_files[:5]:
            print(f"  • {json_file.relative_to(project_path)}")
        if len(json_files) > 5:
            print(f"  ... and {len(json_files) - 5} more")
    
    if audio_files:
        print(f"\nAUDIO FILES TO REMOVE ({len(audio_files)}):")
        for audio_file in audio_files[:5]:
            print(f"  • {audio_file.relative_to(project_path)}")
        if len(audio_files) > 5:
            print(f"  ... and {len(audio_files) - 5} more")
    
    if other_files:
        print(f"\nOTHER FILES TO REMOVE ({len(other_files)}):")
        for other_file in other_files[:5]:
            print(f"  • {other_file.relative_to(project_path)}")
        if len(other_files) > 5:
            print(f"  ... and {len(other_files) - 5} more")
    
    total_items = len(dirs_to_clean) + len(unique_files) + (len(pycache_dirs) if clean_cache else 0)
    
    if total_items == 0:
        print("\n" + "="*60)
        print("✓ No test files or cache directories found to clean.")
        print("="*60)
        return
    
    print("\n" + "="*60)
    print(f"TOTAL ITEMS TO REMOVE: {total_items}")
    print("="*60)
    
    if confirm:
        print(f"\n⚠️  WARNING: This will permanently delete all listed files and directories!")
        response = input("Do you want to proceed? (yes/N): ").lower()
        if response not in ['y', 'yes']:
            print("\n✗ Cleanup cancelled.")
            return
    
    # Perform cleanup
    removed_dirs = 0
    removed_files = 0
    removed_pycache = 0
    errors = []
    
    print(f"\n" + "="*60)
    print("CLEANING UP...")
    print("="*60)
    
    # Remove test directories
    for dir_path in dirs_to_clean:
        try:
            if dir_path.exists():
                shutil.rmtree(dir_path)
                removed_dirs += 1
                print(f"✓ Removed directory: {dir_path.relative_to(project_path)}")
        except Exception as e:
            errors.append(f"Could not remove directory {dir_path.relative_to(project_path)}: {e}")
            print(f"✗ Error removing {dir_path.relative_to(project_path)}: {e}")
    
    # Remove __pycache__ directories
    if clean_cache:
        for cache_dir in pycache_dirs:
            try:
                if cache_dir.exists():
                    shutil.rmtree(cache_dir)
                    removed_pycache += 1
                    if removed_pycache <= 5:
                        print(f"✓ Removed __pycache__: {cache_dir.relative_to(project_path)}")
            except Exception as e:
                errors.append(f"Could not remove __pycache__ {cache_dir.relative_to(project_path)}: {e}")
        
        if removed_pycache > 5:
            print(f"✓ ... and {removed_pycache - 5} more __pycache__ directories")
    
    # Remove individual files
    for file_path in unique_files:
        try:
            if file_path.exists():
                file_path.unlink()
                removed_files += 1
                if removed_files <= 10:
                    print(f"✓ Removed file: {file_path.relative_to(project_path)}")
        except Exception as e:
            errors.append(f"Could not remove file {file_path.relative_to(project_path)}: {e}")
    
    if removed_files > 10:
        print(f"✓ ... and {removed_files - 10} more files")
    
    # Summary
    print(f"\n" + "="*60)
    print("CLEANUP COMPLETED!")
    print("="*60)
    print(f"✓ Removed {removed_dirs} test directories")
    print(f"✓ Removed {removed_files} test files")
    if clean_cache:
        print(f"✓ Removed {removed_pycache} __pycache__ directories")
    print(f"\nTotal items removed: {removed_dirs + removed_files + removed_pycache}")
    
    if errors:
        print(f"\n⚠️  ERRORS ENCOUNTERED ({len(errors)}):")
        for error in errors[:5]:
            print(f"  • {error}")
        if len(errors) > 5:
            print(f"  ... and {len(errors) - 5} more errors")
    else:
        print("\n✓ All test files and directories cleaned successfully!")
    
    print("="*60)

def main():
    parser = argparse.ArgumentParser(
        description="Clean up test files, __pycache__, and temporary files.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Preview what will be deleted (dry run)
  python cleanup_test_files.py --dry_run
  
  # Clean test files only (no __pycache__)
  python cleanup_test_files.py --no_cache
  
  # Clean everything including __pycache__ without confirmation
  python cleanup_test_files.py --yes
  
  # Clean with custom project directory
  python cleanup_test_files.py --project_dir /path/to/project --yes
        """
    )
    
    parser.add_argument("--project_dir", type=str,
                       default="/home/jieshiang/Desktop/GitHub/Codec_comparison",
                       help="Project root directory path (default: %(default)s)")
    parser.add_argument("--yes", action="store_true",
                       help="Skip confirmation prompt")
    parser.add_argument("--dry_run", action="store_true", 
                       help="Show what would be deleted without actually deleting")
    parser.add_argument("--no_cache", action="store_true",
                       help="Skip cleaning __pycache__ directories")
    
    args = parser.parse_args()
    
    clean_cache = not args.no_cache
    
    if args.dry_run:
        print("\n" + "="*60)
        print("DRY RUN MODE - No files will be deleted")
        print("="*60)
        cleanup_test_files(args.project_dir, confirm=False, clean_cache=clean_cache)
        print("\n" + "="*60)
        print("✓ Dry run completed. Use without --dry_run to actually delete files.")
        print("="*60)
    else:
        cleanup_test_files(args.project_dir, confirm=not args.yes, clean_cache=clean_cache)

if __name__ == "__main__":
    main()